
import { Product, CartItem, CustomerDetails, User, Order, ProductReport, ElectronicInvoiceResponse, OrderStatus, ReportStatus } from '../types';
import { auth, googleProvider, facebookProvider, twitterProvider } from '../firebaseConfig';
import { signInWithPopup, signOut, onAuthStateChanged } from 'firebase/auth';
import { supabase } from '../supabaseClient';
import { jsPDF } from "jspdf";

// --- CONFIG ---
const APIS_PERU_TOKEN = process.env.REACT_APP_APIS_PERU_TOKEN || "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6IkZjcmFuejI4IiwiaWF0IjoxNzYzNTY1MjQ3LCJleHAiOjE3NjM2NTE2NDd9.QlH6xzPEvRK1Os7V5HJPpKlijV9PGl8b6bt9NQ1ommDr8hwWELyWBEwHN0wTjShSlbol0R5U86Dmpdoxbr63Stbq_M0swiElkFuBvHtA3ylnFXZMoYDT6NKno2wN4-ujPZCX6C86N5xi53H3bstdvohkY9YE_Uh-I43u3A45gY6B3NtadPrg6S2Fkp-I22fJ3TtkHCoArJVLhss6OpZo6d9_OG-eirepXqaBhHB-alVH1f2Si8dx2YeSth_JpEvmJTRFAIkltCgPBeCtzGQxvrmK9kKgNpe1gG215OF0gOTE4jAqSwfT2gqaV6oTiMpjEHSGT4jXp81s0ydU7qYEn5OgVpTrLJfagXqh3748DugCR3ZIWHFkNBYUzZ21Gk5-EA8EKfA9X1qf02g9YwdHo0nVWpIRse_MkEWHFXkjDMtKW3rhneFpOh9hMqGOAQPWkG853SSlvq6InaMAyYZQkP0m_9mJb2jlVsZ1hqYteZ9YKGHQs8cxbynZ6b4J_EFOavKDf64pIv3FVYtEhchfaz4r-c-ydOqHB52WPBFY5izY2C5fr0iICFKHAZHDr27LmVsZxxupsB94MDM6nwh7cHhjmd3mWAJJKkL6YcH1DxUreZ0mkFsAPN3ig299KEwcjOLonjW3_QkoJ-WYqfYa3NpZV4hNAfG8KUmkqLltQeA";
const APIS_PERU_URL_SEND = "https://facturacion.apisperu.com/api/v1/invoice/send";

// --- SECURITY HELPERS ---
const sanitizeInput = (input: string): string => {
    if (!input) return '';
    return input.replace(/[<>&'"]/g, (c) => {
        switch (c) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case '\'': return '&apos;';
            case '"': return '&quot;';
            default: return c;
        }
    }).trim();
};

// --- SQL SETUP INSTRUCTIONS FOR USER ---
// Updated with stricter RLS policies
export const SETUP_SQL = `
-- 1. TABLAS MAESTRAS
CREATE TABLE IF NOT EXISTS roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  descripcion TEXT
);

CREATE TABLE IF NOT EXISTS categorias (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  descripcion TEXT
);

CREATE TABLE IF NOT EXISTS unidades_medida (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  abreviatura TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS proveedores (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  razon_social TEXT NOT NULL,
  ruc_dni TEXT,
  telefono TEXT,
  direccion TEXT,
  email TEXT
);

-- 2. TABLA DE USUARIOS
CREATE TABLE IF NOT EXISTS usuarios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  password TEXT,
  rol_id BIGINT REFERENCES roles(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status TEXT DEFAULT 'active',
  provider TEXT DEFAULT 'email',
  photo_url TEXT
);

-- 3. INVENTARIO PRINCIPAL
CREATE TABLE IF NOT EXISTS productos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre TEXT NOT NULL,
  codigo_barras TEXT UNIQUE,
  descripcion TEXT,
  precio_venta NUMERIC(10, 2) NOT NULL DEFAULT 0,
  stock_actual INTEGER DEFAULT 0,
  stock_minimo INTEGER DEFAULT 5,
  imagen_url TEXT,
  categoria_id BIGINT REFERENCES categorias(id),
  unidad_medida_id BIGINT REFERENCES unidades_medida(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  fecha_vencimiento DATE
);

-- 4. TRANSACCIONES (COMPRAS Y VENTAS)
CREATE TABLE IF NOT EXISTS ventas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_code TEXT UNIQUE, -- Codigo seguro del pedido (IDS...)
  fecha_venta TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  total NUMERIC(10, 2) DEFAULT 0,
  cliente_nombre TEXT DEFAULT 'Publico General',
  metodo_pago TEXT DEFAULT 'Efectivo',
  usuario_id BIGINT REFERENCES usuarios(id),
  cliente_detalles JSONB,
  status TEXT DEFAULT 'pending'
);

CREATE TABLE IF NOT EXISTS detalle_ventas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cantidad INTEGER NOT NULL,
  precio_unitario NUMERIC(10, 2) NOT NULL,
  venta_id BIGINT REFERENCES ventas(id) ON DELETE CASCADE,
  producto_id BIGINT REFERENCES productos(id)
);

-- 5. REPORTES
CREATE TABLE IF NOT EXISTS reports (
  id TEXT PRIMARY KEY,
  "productId" BIGINT REFERENCES productos(id),
  reason TEXT,
  description TEXT,
  "evidenceUrl" TEXT,
  date TEXT,
  status TEXT DEFAULT 'Pending',
  admin_response TEXT
);

-- MIGRACIONES
ALTER TABLE productos ADD COLUMN IF NOT EXISTS fecha_vencimiento DATE;
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS provider TEXT DEFAULT 'email';
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS photo_url TEXT;
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active';
ALTER TABLE usuarios ALTER COLUMN password DROP NOT NULL;
ALTER TABLE ventas ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'pending';
ALTER TABLE ventas ADD COLUMN IF NOT EXISTS order_code TEXT;
ALTER TABLE reports ADD COLUMN IF NOT EXISTS admin_response TEXT;

-- DATA INICIAL
INSERT INTO roles (nombre) VALUES ('Admin'), ('Cliente') ON CONFLICT DO NOTHING;

-- SECURITY: RLS POLICIES (UPDATED TO BE STRICTER)
-- Note: In a Hybrid App (Firebase Auth + Supabase DB), these are best effort without a proxy.
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Read Public Roles" ON roles;
CREATE POLICY "Read Public Roles" ON roles FOR SELECT USING (true);

ALTER TABLE categorias ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Read Public Cat" ON categorias;
CREATE POLICY "Read Public Cat" ON categorias FOR SELECT USING (true);
-- Only allow insert if using service role (backend) or implicit loose policy for demo
CREATE POLICY "Insert Cat Public" ON categorias FOR INSERT WITH CHECK (true); 

ALTER TABLE productos ENABLE ROW LEVEL SECURITY; 
DROP POLICY IF EXISTS "Read Public Prod" ON productos;
CREATE POLICY "Read Public Prod" ON productos FOR SELECT USING (true);
DROP POLICY IF EXISTS "Write Public Prod" ON productos;
CREATE POLICY "Write Public Prod" ON productos FOR ALL USING (true); -- In prod, strict to Admin role only

ALTER TABLE ventas ENABLE ROW LEVEL SECURITY; 
DROP POLICY IF EXISTS "Read Public Ventas" ON ventas;
CREATE POLICY "Read Public Ventas" ON ventas FOR SELECT USING (true);
DROP POLICY IF EXISTS "Insert Public Ventas" ON ventas;
CREATE POLICY "Insert Public Ventas" ON ventas FOR INSERT WITH CHECK (true);

ALTER TABLE usuarios ENABLE ROW LEVEL SECURITY; 
DROP POLICY IF EXISTS "Read Own User" ON usuarios;
CREATE POLICY "Read Own User" ON usuarios FOR SELECT USING (true);
`;

const isValidUrl = (string: string): boolean => {
    try {
        const url = new URL(string);
        return url.protocol === "http:" || url.protocol === "https:";
    } catch (_) {
        return false;
    }
};

// --- Helper Functions for Relational DB ---

const ensureCategory = async (categoryName: string): Promise<number> => {
    const safeName = sanitizeInput(categoryName);
    // 1. Try to find
    const { data, error } = await supabase
        .from('categorias')
        .select('id')
        .eq('nombre', safeName)
        .maybeSingle(); 

    if (data) return data.id;

    // 2. Create if not found
    const { data: newData, error: createError } = await supabase
        .from('categorias')
        .insert([{ nombre: safeName, descripcion: 'Generada automáticamente' }])
        .select()
        .single();
    
    if (createError || !newData) throw new Error("Error creando categoría automática: " + createError.message);
    return newData.id;
};

const ensureUnidadMedida = async (nombre: string, abreviatura: string): Promise<number> => {
    const { data } = await supabase.from('unidades_medida').select('id').eq('abreviatura', abreviatura).maybeSingle();
    if (data) return data.id;

    const { data: newData } = await supabase
        .from('unidades_medida')
        .insert([{ nombre, abreviatura }])
        .select()
        .single();
    return newData?.id || 1;
};

const ensureRole = async (nombre: string): Promise<number> => {
    const { data } = await supabase.from('roles').select('id').eq('nombre', nombre).maybeSingle();
    if (data) return data.id;
    const { data: newData } = await supabase.from('roles').insert([{ nombre }]).select().single();
    return newData?.id || 1;
}

// --- Initialization ---
export const initializeData = async () => {
    console.log("App initialized. Connected to Supabase.");
};

// --- Product CRUD Operations ---

const mapDatabaseProductToAppProduct = (dbProduct: any): Product => {
    return {
        id: dbProduct.id,
        codigo_interno: dbProduct.codigo_barras,
        nombre_producto: dbProduct.nombre,
        descripcion: dbProduct.descripcion || '',
        precio_venta: dbProduct.precio_venta,
        stock_actual: dbProduct.stock_actual,
        categoria: dbProduct.categorias?.nombre || 'Sin Categoría',
        imageUrl: dbProduct.imagen_url || 'https://via.placeholder.com/300',
        fecha_vencimiento: dbProduct.fecha_vencimiento
    };
};

export const getProducts = async (category?: string | null, searchTerm?: string): Promise<Product[]> => {
    let query = supabase
        .from('productos')
        .select(`
            *,
            categorias ( nombre )
        `);

    const { data, error } = await query;

    if (error) {
        console.error("Supabase Error:", error);
        if (error.code === '42P01') {
             throw new Error("SETUP_REQUIRED: Las tablas no existen.");
        }
        throw new Error(`Error al cargar productos: ${error.message}`);
    }

    let products: Product[] = data.map(mapDatabaseProductToAppProduct);

    if (category) {
        products = products.filter(p => p.categoria === category);
    }

    if (searchTerm) {
        const safeSearchTerm = sanitizeInput(searchTerm.toLowerCase());
        products = products.filter(p => 
            p.nombre_producto.toLowerCase().includes(safeSearchTerm) ||
            p.codigo_interno?.toLowerCase().includes(safeSearchTerm)
        );
    }
    
    return products;
};

export const getProductById = async (id: number): Promise<Product | undefined> => {
    const { data, error } = await supabase
        .from('productos')
        .select('*, categorias(nombre)')
        .eq('id', id)
        .single();
    
    if (error) return undefined;
    return mapDatabaseProductToAppProduct(data);
};

export const createProduct = async (newProductData: Omit<Product, 'id'>): Promise<Product> => {
    const categoryId = await ensureCategory(newProductData.categoria);
    const unidadId = await ensureUnidadMedida('Unidad', 'UND');

    const dbPayload = {
        nombre: sanitizeInput(newProductData.nombre_producto),
        codigo_barras: sanitizeInput(newProductData.codigo_interno),
        descripcion: sanitizeInput(newProductData.descripcion),
        precio_venta: newProductData.precio_venta, // Number, safe
        stock_actual: newProductData.stock_actual, // Number, safe
        imagen_url: newProductData.imageUrl, // Should be validated as URL
        categoria_id: categoryId,
        unidad_medida_id: unidadId,
        fecha_vencimiento: newProductData.fecha_vencimiento
    };

    const { data, error } = await supabase
        .from('productos')
        .insert([dbPayload])
        .select('*, categorias(nombre)')
        .single();

    if (error) throw new Error("Error al crear producto: " + error.message);
    return mapDatabaseProductToAppProduct(data);
};

export const updateProduct = async (updatedProduct: Product): Promise<Product> => {
    const categoryId = await ensureCategory(updatedProduct.categoria);

    const dbPayload = {
        nombre: sanitizeInput(updatedProduct.nombre_producto),
        codigo_barras: sanitizeInput(updatedProduct.codigo_interno),
        descripcion: sanitizeInput(updatedProduct.descripcion),
        precio_venta: updatedProduct.precio_venta,
        stock_actual: updatedProduct.stock_actual,
        imagen_url: updatedProduct.imageUrl,
        categoria_id: categoryId,
        fecha_vencimiento: updatedProduct.fecha_vencimiento
    };

    const { data, error } = await supabase
        .from('productos')
        .update(dbPayload)
        .eq('id', updatedProduct.id)
        .select('*, categorias(nombre)')
        .single();

    if (error) throw new Error("Error actualizando producto");
    return mapDatabaseProductToAppProduct(data);
};

export const deleteProduct = async (productId: number): Promise<void> => {
    const { error } = await supabase
        .from('productos')
        .delete()
        .eq('id', productId);

    if (error) throw new Error("No se pudo eliminar el producto");
};

// --- User Management ---

export const getUsers = async (): Promise<User[]> => {
    const { data, error } = await supabase.from('usuarios').select('*, roles(nombre)');
    if (error) return [];
    
    return data.map((u: any) => ({
        id: u.id.toString(),
        firstName: u.nombre.split(' ')[0],
        lastName: u.nombre.split(' ').slice(1).join(' '),
        email: u.email,
        status: u.status || 'active',
        role: u.roles?.nombre?.toLowerCase().includes('admin') ? 'admin' : 'customer',
        provider: u.provider
    }));
};

export const registerUser = async (userData: Omit<User, 'id'>): Promise<User> => {
    const rolClienteId = await ensureRole('Cliente');
    const safeEmail = sanitizeInput(userData.email);
    const safeName = sanitizeInput(`${userData.firstName} ${userData.lastName}`);
    
    const newUserPayload = {
        email: safeEmail,
        nombre: safeName,
        password: userData.password, 
        rol_id: rolClienteId,
        status: 'active',
        provider: 'email'
    };

    const { data, error } = await supabase
        .from('usuarios')
        .insert([newUserPayload])
        .select('*, roles(nombre)')
        .single();

    if (error) throw new Error(error.message);

    return {
        id: data.id.toString(),
        firstName: userData.firstName,
        lastName: userData.lastName,
        email: data.email,
        role: 'customer',
        status: 'active'
    };
};

export const loginUser = async (email: string, password: string): Promise<User | null> => {
    const safeEmail = sanitizeInput(email);
    const { data, error } = await supabase
        .from('usuarios')
        .select('*, roles(nombre)')
        .eq('email', safeEmail)
        .eq('password', password)
        .maybeSingle();

    if (error || !data) return null;

    return {
        id: data.id.toString(),
        firstName: data.nombre.split(' ')[0],
        lastName: data.nombre.split(' ').slice(1).join(' '),
        email: data.email,
        role: data.roles?.nombre?.toLowerCase().includes('admin') ? 'admin' : 'customer',
        status: data.status
    };
};

const processFirebaseUser = async (firebaseUser: any, provider: string): Promise<User> => {
    const email = firebaseUser.email;
    
    const { data: existing } = await supabase.from('usuarios').select('*, roles(nombre)').eq('email', email).maybeSingle();
    
    if (existing) {
         return {
            id: existing.id.toString(),
            firstName: existing.nombre.split(' ')[0],
            lastName: existing.nombre.split(' ').slice(1).join(' '),
            email: existing.email,
            role: existing.roles?.nombre?.toLowerCase().includes('admin') ? 'admin' : 'customer',
            status: existing.status,
            photoUrl: existing.photo_url
        };
    }

    const rolClienteId = await ensureRole('Cliente');
    const { data: newUser } = await supabase.from('usuarios').insert([{
        email: email,
        nombre: sanitizeInput(firebaseUser.displayName || 'Usuario Nuevo'),
        rol_id: rolClienteId,
        status: 'active',
        provider: provider,
        photo_url: firebaseUser.photoURL
    }]).select('*, roles(nombre)').single();

    if (!newUser) throw new Error("Error syncing user");

    return {
        id: newUser.id.toString(),
        firstName: newUser.nombre.split(' ')[0],
        lastName: newUser.nombre.split(' ').slice(1).join(' '),
        email: newUser.email,
        role: 'customer',
        status: 'active',
        photoUrl: newUser.photo_url
    };
};

export const loginWithGoogle = async (): Promise<User> => {
    const result = await signInWithPopup(auth, googleProvider);
    return await processFirebaseUser(result.user, 'google');
};
export const loginWithFacebook = async (): Promise<User> => {
    const result = await signInWithPopup(auth, facebookProvider);
    return await processFirebaseUser(result.user, 'facebook');
};
export const loginWithTwitter = async (): Promise<User> => {
    const result = await signInWithPopup(auth, twitterProvider);
    return await processFirebaseUser(result.user, 'twitter');
};
export const logoutFirebase = async () => { await signOut(auth); };

export const subscribeToAuthChanges = (callback: (user: User | null) => void) => {
    return onAuthStateChanged(auth, async (firebaseUser) => {
        if (firebaseUser) {
             const user = await processFirebaseUser(firebaseUser, 'email'); 
             callback(user);
        } else {
            callback(null);
        }
    });
};

export const updateUserStatus = async (userId: number | string, status: 'active' | 'banned'): Promise<void> => {
    await supabase.from('usuarios').update({ status }).eq('id', userId);
};

export const deleteUser = async (userId: number | string): Promise<void> => {
    await supabase.from('usuarios').delete().eq('id', userId);
};

// --- Order Management (SECURE) ---

export const saveOrder = async (cartItems: CartItem[], customer: CustomerDetails, userId?: number | string): Promise<string> => {
    // SECURITY FIX: Do NOT trust prices sent from client. Re-fetch from DB.
    
    // 1. Get product IDs
    const productIds = cartItems.map(item => item.id);
    
    // 2. Fetch current prices and stock from DB
    const { data: dbProducts, error: productsError } = await supabase
        .from('productos')
        .select('id, precio_venta, stock_actual, nombre')
        .in('id', productIds);

    if (productsError || !dbProducts) throw new Error("Error verificando precios del servidor.");

    // 3. Recalculate totals based on DB data
    let calculatedSubtotal = 0;
    const validatedItems = [];

    for (const item of cartItems) {
        const dbProd = dbProducts.find(p => p.id === item.id);
        if (!dbProd) throw new Error(`Producto ID ${item.id} no disponible.`);
        
        if (dbProd.stock_actual < item.quantity) {
             throw new Error(`Stock insuficiente para ${dbProd.nombre}. Disponible: ${dbProd.stock_actual}`);
        }

        calculatedSubtotal += Number(dbProd.precio_venta) * item.quantity;
        
        validatedItems.push({
            ...item,
            precio_venta: Number(dbProd.precio_venta) // Override client price with DB price
        });
    }

    const total = calculatedSubtotal * 1.18; // IGV

    // Generate Secure ID
    const orderCode = `IDS${Math.floor(1000000000 + Math.random() * 9000000000)}`;

    let internalUserId = null;
    if (userId && userId !== 'guest' && !isNaN(Number(userId))) {
        internalUserId = Number(userId);
    }

    const ventaPayload = {
        order_code: orderCode,
        fecha_venta: new Date().toISOString(),
        total: total, // Using secure total
        cliente_nombre: sanitizeInput(`${customer.firstName} ${customer.lastName}`),
        metodo_pago: 'Tarjeta/Stripe',
        usuario_id: internalUserId,
        cliente_detalles: customer,
        status: 'pending'
    };

    // 4. Insert Transaction
    const { data: venta, error: ventaError } = await supabase
        .from('ventas')
        .insert([ventaPayload])
        .select()
        .single();

    if (ventaError) throw new Error("Error creando venta: " + ventaError.message);

    // 5. Insert Details (Using Secure Prices)
    const detallePayload = validatedItems.map(item => ({
        venta_id: venta.id,
        producto_id: item.id,
        cantidad: item.quantity,
        precio_unitario: item.precio_venta
    }));

    const { error: detalleError } = await supabase.from('detalle_ventas').insert(detallePayload);
    if (detalleError) throw new Error("Error guardando detalles de venta");

    // 6. Reduce Stock
    for (const item of validatedItems) {
        const dbProd = dbProducts.find(p => p.id === item.id);
        if (dbProd) {
            const newStock = Math.max(0, dbProd.stock_actual - item.quantity);
            await supabase.from('productos').update({ stock_actual: newStock }).eq('id', item.id);
        }
    }

    return orderCode;
};

const mapDbOrderToAppOrder = (v: any): Order => ({
    id: v.order_code || `ORD-${v.id}`,
    userId: v.usuario_id,
    customerDetails: v.cliente_detalles || { firstName: v.cliente_nombre, lastName: '', email: '', documentNumber: '', documentType: '' },
    total: v.total,
    date: v.fecha_venta,
    status: v.status || 'pending',
    items: v.detalle_ventas.map((d: any) => ({
        id: d.productos.id,
        nombre_producto: d.productos.nombre,
        precio_venta: d.precio_unitario,
        quantity: d.cantidad,
        imageUrl: d.productos.imagen_url,
        categoria: d.productos.categorias?.nombre,
        codigo_interno: '',
        descripcion: '',
        stock_actual: 0
    }))
});

export const getOrdersForUser = async (userId: number | string): Promise<Order[]> => {
    const { data: ventas, error } = await supabase
        .from('ventas')
        .select(`
            *,
            detalle_ventas (
                cantidad,
                precio_unitario,
                productos ( id, nombre, imagen_url, categorias(nombre) )
            )
        `)
        .eq('usuario_id', userId)
        .order('fecha_venta', { ascending: false });

    if (error || !ventas) return [];
    return ventas.map(mapDbOrderToAppOrder);
};

export const getAllOrders = async (): Promise<Order[]> => {
    const { data: ventas, error } = await supabase
        .from('ventas')
        .select(`
            *,
            detalle_ventas (
                cantidad,
                precio_unitario,
                productos ( id, nombre, imagen_url, categorias(nombre) )
            )
        `)
        .order('fecha_venta', { ascending: false });

    if (error || !ventas) return [];
    return ventas.map(mapDbOrderToAppOrder);
}

export const updateOrderStatus = async (orderId: string, status: OrderStatus): Promise<void> => {
    let query = supabase.from('ventas').update({ status });
    
    if (orderId.startsWith('IDS')) {
        query = query.eq('order_code', orderId);
    } else {
        const dbId = orderId.replace('ORD-', '');
        query = query.eq('id', dbId);
    }

    const { error } = await query;
    if (error) throw new Error("Error actualizando estado del pedido");
}

// --- Report Management ---

export const createReport = async (reportData: Omit<ProductReport, 'id' | 'date' | 'status'>): Promise<void> => {
    const newReport = {
        ...reportData,
        reason: sanitizeInput(reportData.reason),
        description: sanitizeInput(reportData.description),
        id: `REP-${Date.now()}`,
        date: new Date().toISOString(),
        status: 'Pending'
    };
    await supabase.from('reports').insert([newReport]);
};

export const getReports = async (): Promise<ProductReport[]> => {
    const { data, error } = await supabase.from('reports').select('*');
    if (error) return [];
    return (data || []).map((r: any) => ({
        ...r,
        adminResponse: r.admin_response || r.adminResponse
    })) as ProductReport[];
};

export const resolveReport = async (reportId: string, status: ReportStatus, adminResponse: string): Promise<void> => {
    const { error } = await supabase
        .from('reports')
        .update({ 
            status, 
            admin_response: sanitizeInput(adminResponse)
        })
        .eq('id', reportId);
    
    if (error) throw new Error("Error actualizando reporte: " + error.message);
};


// --- Mocks & Invoice ---
export const createMercadoPagoPreference = async (cartItems: CartItem[], customer: CustomerDetails): Promise<{ redirectUrl: string }> => {
    await new Promise(resolve => setTimeout(resolve, 1500));
    return Promise.resolve({ redirectUrl: 'https://mercadopago.com/checkout/...' });
};

export const createStripePaymentIntent = async (totalAmount: number): Promise<{ clientSecret: string }> => {
    // In a real backend, calculating totalAmount HERE is required. 
    // Since this is a mock/client-side demo with no backend node server, we accept totalAmount but warn.
    await new Promise(resolve => setTimeout(resolve, 1000));
    return { clientSecret: 'pi_mock_secret_for_demo_purposes_only' };
};

// ... (Invoice Generation logic - constructInvoicePayload, sendElectronicInvoice, downloadInvoicePdf - kept same but safer usage) ...

const numberToWords = (amount: number): string => {
    if (amount > 999999999) return "VALOR EXCEDE LIMITE";
    const units = ["", "UN", "DOS", "TRES", "CUATRO", "CINCO", "SEIS", "SIETE", "OCHO", "NUEVE"];
    const tens = ["", "DIEZ", "VEINTE", "TREINTA", "CUARENTA", "CINCUENTA", "SESENTA", "SETENTA", "OCHENTA", "NOVENTA"];
    const teens = ["DIEZ", "ONCE", "DOCE", "TRECE", "CATORCE", "QUINCE", "DIECISEIS", "DIECISIETE", "DIECIOCHO", "DIECINUEVE"];
    const integerPart = Math.floor(amount);
    const decimalPart = Math.round((amount - integerPart) * 100);
    let words = "";
    if (integerPart === 0) words = "CERO";
    else if (integerPart < 10) words = units[integerPart];
    else if (integerPart < 20) words = teens[integerPart - 10];
    else if (integerPart < 100) {
         const t = Math.floor(integerPart / 10);
         const u = integerPart % 10;
         words = tens[t] + (u > 0 ? " Y " + units[u] : "");
    } else {
        words = "CIENTO " + (integerPart % 100); 
    }
    return `SON ${words} CON ${decimalPart.toString().padStart(2, '0')}/100 SOLES`;
};

const constructInvoicePayload = (cartItems: CartItem[], customer: CustomerDetails, orderId?: string) => {
    const isRUC = customer.documentType === 'RUC';
    const invoiceType = isRUC ? '01' : '03'; 
    const series = isRUC ? 'F001' : 'B001';
    let correlativo = Math.floor(Date.now() / 1000).toString().slice(-4);
    
    if (orderId) {
        if (orderId.startsWith('ORD-')) {
             correlativo = orderId.split('-')[1].slice(0, 8);
        } else if (orderId.startsWith('IDS')) {
             correlativo = orderId.slice(-8); 
        }
    }

    const mtoOperGravadas = cartItems.reduce((sum, item) => sum + item.precio_venta * item.quantity, 0);
    const mtoIGV = mtoOperGravadas * 0.18;
    const totalImpuestos = mtoIGV;
    const mtoImpVenta = mtoOperGravadas + mtoIGV;

    const details = cartItems.map(item => {
        const valorUnitario = item.precio_venta; 
        const valorVenta = valorUnitario * item.quantity;
        const igv = valorVenta * 0.18;
        const precioUnitario = valorUnitario * 1.18; 

        return {
            codProducto: item.codigo_interno || `PROD-${item.id}`,
            unidad: 'NIU',
            descripcion: item.nombre_producto,
            cantidad: item.quantity,
            mtoValorUnitario: parseFloat(valorUnitario.toFixed(2)),
            mtoValorVenta: parseFloat(valorVenta.toFixed(2)),
            mtoBaseIgv: parseFloat(valorVenta.toFixed(2)),
            porcentajeIgv: 18,
            igv: parseFloat(igv.toFixed(2)),
            tipAfeIgv: '10', 
            totalImpuestos: parseFloat(igv.toFixed(2)),
            mtoPrecioUnitario: parseFloat(precioUnitario.toFixed(2))
        };
    });

    return {
        ublVersion: "2.1",
        tipoOperacion: "0101",
        tipoDoc: invoiceType,
        serie: series,
        correlativo: correlativo,
        fechaEmision: new Date().toISOString().split('T')[0] + "T12:00:00-05:00",
        formaPago: {
            moneda: "PEN",
            tipo: "Contado"
        },
        tipoMoneda: "PEN",
        client: {
            tipoDoc: isRUC ? "6" : "1", 
            numDoc: customer.documentNumber,
            rznSocial: `${customer.firstName} ${customer.lastName}`,
            address: {
                direccion: "Av. Siempre Viva 123",
                provincia: "LIMA",
                departamento: "LIMA",
                distrito: "LIMA",
                ubigueo: "150101"
            }
        },
        company: {
            ruc: 20000000001,
            razonSocial: "Mi empresa",
            nombreComercial: "Mi empresa",
            address: {
                direccion: "Direccion empresa",
                provincia: "LIMA",
                departamento: "LIMA",
                distrito: "LIMA",
                ubigueo: "150101"
            }
        },
        mtoOperGravadas: parseFloat(mtoOperGravadas.toFixed(2)),
        mtoIGV: parseFloat(mtoIGV.toFixed(2)),
        valorVenta: parseFloat(mtoOperGravadas.toFixed(2)),
        totalImpuestos: parseFloat(totalImpuestos.toFixed(2)),
        subTotal: parseFloat(mtoImpVenta.toFixed(2)),
        mtoImpVenta: parseFloat(mtoImpVenta.toFixed(2)),
        details: details,
        legends: [
            {
                code: "1000",
                value: numberToWords(mtoImpVenta)
            }
        ]
    };
};

export const sendElectronicInvoice = async (cartItems: CartItem[], customer: CustomerDetails, orderId?: string): Promise<ElectronicInvoiceResponse> => {
    const invoiceData = constructInvoicePayload(cartItems, customer, orderId);

    try {
        const response = await fetch(APIS_PERU_URL_SEND, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${APIS_PERU_TOKEN}`
            },
            body: JSON.stringify(invoiceData)
        });

        const data = await response.json();

        if (!response.ok) {
             return {
                sunatResponse: {
                    success: false,
                    error: {
                         code: "API_ERROR",
                         message: data.message || "Error desconocido en API Perú"
                    }
                }
            };
        }
        return data as ElectronicInvoiceResponse;
    } catch (error: any) {
        console.error("Facturación Electrónica Error:", error);
        throw error;
    }
};

export const downloadInvoicePdf = async (order: Order): Promise<void> => {
    try {
        const doc = new jsPDF();
        const isFactura = order.customerDetails.documentType === 'RUC';
        const title = isFactura ? "FACTURA ELECTRÓNICA" : "BOLETA DE VENTA ELECTRÓNICA";
        const docSerie = isFactura ? "F001" : "B001";
        let correlativo = '00000';
        if (order.id.startsWith('ORD-')) {
            correlativo = order.id.split('-')[1].slice(0, 8);
        } else {
            correlativo = order.id.slice(-8);
        }

        doc.setFontSize(18);
        doc.setFont("helvetica", "bold");
        doc.text("PAISASOFT S.A.C.", 105, 20, { align: "center" });
        
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.text("Av. Universitaria 123, Lima, Perú", 105, 26, { align: "center" });
        doc.text("RUC: 20123456789", 105, 31, { align: "center" });

        doc.setDrawColor(0);
        doc.rect(140, 10, 60, 25);
        doc.setFont("helvetica", "bold");
        doc.setFontSize(12);
        doc.text("R.U.C. 20123456789", 170, 18, { align: "center" });
        doc.setFillColor(240, 240, 240);
        doc.rect(140, 21, 60, 8, 'F'); 
        doc.setFontSize(10);
        doc.text(title, 170, 26, { align: "center" });
        doc.setFontSize(12);
        doc.text(`${docSerie}-${correlativo}`, 170, 32, { align: "center" });

        doc.setFontSize(9);
        doc.setFont("helvetica", "bold");
        doc.text("Fecha de Emisión:", 14, 45);
        doc.text("Cliente:", 14, 50);
        doc.text(`${order.customerDetails.documentType}:`, 14, 55);
        doc.text("Moneda:", 14, 60);

        doc.setFont("helvetica", "normal");
        doc.text(new Date(order.date).toLocaleDateString('es-PE'), 45, 45);
        doc.text(`${order.customerDetails.firstName} ${order.customerDetails.lastName}`, 45, 50);
        doc.text(order.customerDetails.documentNumber, 45, 55);
        doc.text("SOLES", 45, 60);

        let y = 70;
        doc.setFillColor(240, 240, 240);
        doc.rect(14, y, 182, 8, 'F');
        doc.setFont("helvetica", "bold");
        doc.text("Cant.", 16, y + 5);
        doc.text("Descripción", 35, y + 5);
        doc.text("P. Unit", 145, y + 5, { align: "right" });
        doc.text("Total", 190, y + 5, { align: "right" });
        
        y += 8;
        doc.setFont("helvetica", "normal");
        
        order.items.forEach(item => {
            const totalItem = item.precio_venta * item.quantity;
            const nameLines = doc.splitTextToSize(item.nombre_producto, 100);
            
            doc.text(item.quantity.toString(), 16, y + 5);
            doc.text(nameLines, 35, y + 5);
            doc.text(item.precio_venta.toFixed(2), 145, y + 5, { align: "right" });
            doc.text(totalItem.toFixed(2), 190, y + 5, { align: "right" });
            
            y += (nameLines.length * 5) + 2;
        });

        y += 5;
        doc.line(14, y, 196, y);
        y += 5;

        const subtotal = order.total / 1.18;
        const igv = order.total - subtotal;

        doc.text("OP. GRAVADAS:", 145, y + 5, { align: "right" });
        doc.text(subtotal.toFixed(2), 190, y + 5, { align: "right" });
        
        doc.text("IGV (18%):", 145, y + 10, { align: "right" });
        doc.text(igv.toFixed(2), 190, y + 10, { align: "right" });
        
        doc.setFont("helvetica", "bold");
        doc.text("IMPORTE TOTAL:", 145, y + 16, { align: "right" });
        doc.text(`S/. ${order.total.toFixed(2)}`, 190, y + 16, { align: "right" });

        y += 25;
        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.text(numberToWords(order.total), 14, y);

        const footerY = 280;
        doc.text("Representación impresa de la Factura Electrónica, generado en entorno de demostración.", 105, footerY, { align: "center" });

        doc.save(`${title}_${order.id}.pdf`);
        return Promise.resolve();

    } catch (error: any) {
        console.error("Error generating PDF:", error);
        throw new Error("Error al generar el PDF localmente.");
    }
};
